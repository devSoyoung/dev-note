
# 자바
아직 공부 중, 기초적인 문법과 프로그래밍 언어의 특징만 알고 있는 수준.

## 자바란
* 썬 마이크로 시스템즈에서 개발한 **객체지향** 프로그래밍 언어

## 자바의 특징
### OOP
* **프로그래밍** : 일련의 제어를 통해 원하는 결과를 얻거나 동작을 수행하도록 프로그램을 만드는 것
* (반대개념) **절차지향** : 필요한 제어들을 순서에 따라 절차적으로 나열하는 것
* **객체지향** : 연관 있는 제어와 필요한 속성을 묶어 객체로 만들고, 객체 간의 상호작용을 통해 프로그램을 구성하는 것
* **특징** : 캡슐화, 은닉화, 상속, 다형성

### 멀티 쓰레드 지원
* **쓰레드** : 프로세스(실행중인 프로그램)에서 하나의 실행 흐름
* **멀티쓰레드** : 하나의 프로그램에서 여러 개의 쓰레드를 사용하는 것
* **사용하는 이유** : 입/출력과 같이 대기 시간이 발생했을 때, 기다리는 동안 다른 일을 처리할 수 있도록 하기 위함(처리 속도의 향상)
* **참고링크** : [자바에서 멀티쓰레드 생성하는 법](https://recruit.webtoonscorp.com/webtoon/ko/login/login?annoId=20002577&classId=&jobId=&entTypeCd=004&sysCompanyCd=NW)

### JVM
* **JRE(자바 런타임)** : JVM + Java API
* **자바 바이트코드** : 클래스 파일, JRE에서 동작, 자바 파일이 자바 컴파일러를 통해 바이트코드로 변환됨
* JVM의 클래스로더가 자바 바이트코드를 *[런타임 데이터 영역](https://tramyu.github.io/etc/interview/)*에 로드하고, 실행엔진이 자바 바이트코드 수행
* 따라서 운영체제에 관계없이 동일한 자바 파일을 사용할 수 있음 (OS 종속성)
* = OS 종속성이 적고, *이식성, 보안성이 좋음*
* **클래스 로더** : 컴파일타임이 아니라, 런타임에 클래스를 처음 참조할 때 해당 클래스를 로드/링크 하는 역할을 수행

### 가비지 컬렉션(GC)
* C/C++에서 동적으로 생성한 메모리를 delete로 해제하는 것과 달리 가비지 컬렉터가 알아서 메모리를 회수
* **stop-the-world** : GC를 실행할 때, JVM이 일시적으로 어플리케이션 실행을 멈추는 것
* 위의 상황이 발생하면 GC를 실행하는 쓰레드를 제외한 나머지 쓰레드는 모두 실행을 멈춤 (**GC튜닝** : stop-the-world 시간을 줄이는 것)
* 참고링크 : [GC에 대한 추가적인 내용 - Java Garbage Collection 참고](https://tramyu.github.io/etc/interview/)

## 메모리 영역
* **메서드 영역** : static 변수, 전역변수, class 정보
* (코드에서 사용되는 class들을 로더로 읽어 클래스별로 런타임 필드데이터, 메서드 데이터 등을 분류해 저장)
* **스택** : 지역변수, 함수 등이 할당되는 LIFO 방식의 메모리
* **힙** : new 연산자로 생성된 객체, GC에 의해 메모리 관리

## 접근제어자
* **public** : 접근 제한 없으므로 어디에서나 접근 가능
* **protected** : 클래스가 정의된 패키지 내, 클래스를 상속받은 외부 패키지의 클래스에서 접근 가능 (=패키지 내부, 상속받은 곳)
* **default** : 접근제어자 명시하지 않은 경우, 동일 패키지 내에서만 접근 가능
* **private** : 자기 자신, 클래스 내부에서만 접근 가능

## 추상메서드/추상클래스
* **추상메서드** : 메서드의 정의 부분만 있고 구현부는 없는 것, abstract 키워드를 붙여서 명시
* **추상클래스** : 추상메서드를 적어도 하나 가지고 있는 클래스, 자식클래스에스 오버라이딩이 필요하기 때문에, 객체화(메모리에 올리기) 불가능
* **추상클래스 만들기** : abstract 키워드를 클래스에 명시해주거나, abstract 키워드가 붙은 메서드(구현 없이 정의만 되어있음)를 포함
* 추상클래스를 상속할 경우, 추상메서드들을 반드시 구현해주어야 함

## 클래스/객체
* **클래스** : 객체의 동작과 속성을 추려내서 필드와 메서드로 정의한 것, 메모리 할당되지 않은 상태
* **객체** : 클래스를 기반으로 실제 메모리에 할당되어 사용중인 것

## 인터페이스
* **무엇** : 모든 메서드가 추상메서드인 추상클래스, abstract 키워드 없어도 자동으로 추상메서드로 정의되며, 변수도 `final static` 키워드가 자동으로 붙음
* **왜 사용** : 객체의 내부 구조를 몰라도 메서드의 실행 결과(리턴 타입)를 알기 때문에, 작업이 가능하고 객체가 수정 되더라도 사용하는 부분은 수정하지 않아도 됨
* 특정 작업을 하겠다는 Mark 역할로도 활용

### 추상클래스와의 차이
* **추상클래스** : 상속을 통해 부모 클래스의 기능을 이용/확장하기 위해서 사용, 다중 상속 불가능
* **인터페이스** : 빈 껍데기 형태로 구현할 메소드 정의, 강제해서 서브 클래스에 같은 동작을 보장하기 위해 제공, 다중 상속이 가능
* (자바 8부터 인터페이스에도 default 메소드(=메소드가 구현된 인터페이스) 구현 가능 [[참고링크]](https://asfirstalways.tistory.com/353))


## 오버로딩/오버라이딩
* **오버로딩** : **서로 다른 시그니처**(리턴타입, 파라미터)를 갖는 여러 메소드를 하나의 이름으로 정의
* **오버라이딩** : 상속관계에 있는 자식 클래스에서 부모 클래스에 정의된 메소드를 **재정의**하는 것
* 오버라이딩은 메소드 동작만을 재정의 하는 것이므로, 시그니처가 동일해야 함

***
# SPRING
## 스프링 프레임워크

## 스프링의 구조

## 요청 처리 방식

## bean
### 유효범위(scope)
default는 싱글톤(static으로 공유되고, 한 개만 생성해서 서로 다른 곳에서 공유)
같은 빈으로 여러 객체를 생성했을 경우에 == 연산자로 비교하면 true가 리턴된다.

## 스프링 컨테이너
* bean들의 life cycle(생명주기)를 관리
* 

## DI
* Dependency Injection, 의존 주입
* 설정파일(.xml)을 통해서 객체 간의 의존관계를 설정
* 의존관계를 객체 자신이 아니라 외부의 조립기가 수행
* 각 클래스 사이에 필요로 하는 의존관계를 Bean설정 정보 바탕으로 컨테이너가 자동으로 연결  
* 객체가 직접 의존하고 있는 객체의 생성/검색을 할 필요가 없으므로 코드 관리가 용이해짐

## IoC
* Inversion of Control, 제어의 역전

## AOP
* 관점 지향 프로그래밍, OOP 문제 해결을 위해 등장
* 로그, 트랜젝션, 자원해제, 성능테스트 등 공통적으로 반복(=횡단 관심사)되는 중복 코드가 발생하는 단점 해결을 위함
* **공통의 관심 사항을 적용해서 발생하는 의존 관계의 복잡성과 코드 중복을 해소**
* 개발 코드에서 비즈니스 로직에 집중하고, 실행 시 비즈니스 로직의 앞/뒤 등 원하는 지점에 횡단 관심사를 수행할 수 있게 해서 중복코드를 줄임

## Maven
* 스프링 프로젝트의 대표적인 빌드 툴
* 

## MVC 패턴
* **Model** : 데이터의 처리와 접근을 담당
* **View** : 클라이언트에게 보여지는 부분
* **Controller** : 모델과 뷰를 제어, 
* 이렇게 분리함으로써 얻는 **장점** : 데이터와 화면 간의 의존관계를 벗어날 수 있게 해줌

## 어노테이션
* 메타데이터를 `.xml`에 저장하지 않고, 소스코드에 `@annotation`의 형태로 표현
* 클래스 필드, 메서드의 선언부에 적용할 수 있는 특정 기능이 부여된 표현법
* **등장이유** : 규모의 프로젝트에서 XML설정이 복잡해지기 때문에, 개발자가 설정파일 작업으로 발생하는 오류 빈도를 줄여줌
* **장점** : 소스코드에 메타데이터 보관 가능, 컴파일 타임 체크, 어노테이션 API 사용으로 코드 가독성 향상

### 기본적인 어노테이션
* `@Controller` : 특정 클래스를 컨트롤러로 등록
* `@RequestMapping` : *컨트롤러로 등록된 클래스내에 특정 메서드를 요청되는 URL과 매칭*
* `@Authwired` : Spring에서 자동으로 Dependency Injection을 하기 위한 어노테이션
* `@Service` : 비즈니스 로직 처리 service로 등록
* `@Repository` : Dao로 등록

## Spring JDBC
* 데이터베이스 테이블과 자바 객체 사이의 단순한 매핑을 비교적 간단한 설정을 통해 처리
* 

## Spring Dao


***
# Servlet/JSP
## Servlet
* 웹 기반 요청에 대한 동적 처리가 가능한 서버사이드 자바 프로그램
* 자체적인 실행파일 구조를 가지는 것이 아니라, 다른 환경에 의해 실행되는 단위
* Java 코드 안의 HTML 코드
* 데이터 처리(Controller의 역할)에 좋음 - DB통신, 비즈니스 로직 호출, 데이터 읽고 확인 등
* 서블릿 수정의 경우 자바 코드를 컴파일 한 후 동적 페이지를 처리하기 때문에, 전체 코드 업데이트 및 재배포가 필요 - 개발 생산성 저하

## JSP
* 자바 언어를 기반으로 하는 서버사이드 스크립트 언어
* HTML 코드 안의 Java 코드
* presentation(View)에 좋음 - 요청 결과를 나타내는 HTML 코드
* JSP가 수정된 경우 WAS가 알아서 처리하므로 재배포가 필요 없음

## Servlet, JSP 관계
### JSP만 사용하는 모델
* JSP가 사용자 요청을 받아 bean을 호출하여 적절한 동적 페이지를 생성
* **동작과정**
1. JSP로 작성된 프로그램은 내부적으로 WAS에서 Servlet 파일로 변환
2. JSP 태그를 분해, 추출해서 순수 HTML로 변환
3. 클라이언트에 응답
* **장점** : 개발속도 빠르고, 러닝커브 낮음
* **단점** : 뷰(프레젠테이션 로직)와 컨트롤러(비즈니스 로직) 혼재, 코드 복잡으로 유지보수 어려움 

### JSP와 Servlet를 모두 사용하는 모델 - MVC
* 두 가지를 모두 사용해서 프레젠테이션 로직과 비즈니스 로직 분리
* **뷰**는 JSP, **컨트롤러**는 Servlet, **모델**은 bean이 담당
* 


***
# 디자인 패턴
## Singleton

## Strategy

## Decorator

## Proxy

## Observer



***
# 운영체제
## 프로세스
* OS가 메모리 자원을 할당해 준 실행중인 프로그램
* 각 프로세스는 독자적인 메모리 공간을 가지기 때문에, 프로세스 간 데이터 공유 불가능
* **프로세스 간 데이터 공유** : IPC(InterProcess Communication) 필요 - socket, pipe

### 멀티 프로세스의 문제점
* 생성 비용이 많이 듬
* 컨택스트 스위칭(제어권을 가진 프로세스 전환) 비용이 많이 듬

## 쓰레드
### 멀티 쓰레드의 문제점
* 같은 프로세스 내의 쓰레드 간에는 메모리를 공유하기 때문에, 서로 다른 쓰레드가 같은 메모리에 접근해서 다른 쓰레드의 작업 영역을 침범하는 문제가 발생할 수 있다. 그 결과 의도하지 않은 결과를 얻게 된다.
* **요약**) 크리티컬 섹션(공유 메모리)로 인해 원하지 않는 결과를 얻을 수 있음
* **쓰레드 스케쥴링** : 쓰레드 간의 실행 스케쥴링은 임의로 되기 때문에, 적절하지 못한 순간에 다른 쓰레드로 제어가 넘어가면 위와 같이 예상하지 못한 문제가 발생
* **[해결 방법](https://sibnt.net/186)** : 크리티컬 섹션을 사용 중일 때, 다른 쓰레드가 사용하지 못하도록 함
* = Synchronizaton으로 크리티컬 섹션에 lock을 걸어 다른 쓰레드의 접근 방지(단점: 느려진다)
* **쓰레드 풀** : 쓰레드 생성 갯수를 제한하지 않으면, 메모리를 다 차지할 만큼 쓰레드를 생성할 수 있기 때문에 최대 갯수를 지정해주는 것
* **쓰레드 세이프** : 멀티 쓰레드로 동작하는 프로그램에서 개발자가 의도한 대로 동작하는 것

### 데드락
* 쓰레드 간의 대기상태가 종료되지 않아서 무한정 대기만 하는 상태(교착상태)
* **해결 방법** : 

***
# 웹 프로그래밍
## HTTP
* hypertext transfer protocol

### request method
* **GET** : 데이터를 요청할 때, URL을 통해 전달, 용량 제한 있고 보안 취약(노출)
* **POST** : 서버에 어떤 작업을 수행하고자 할 때, request body로 전달, 용량 제한 없고 보안 좀 더 좋지만 느림
* **PUT** : 수정 작업을 요청할 때, 전체 수정
* **PATCH** : 수정 작업을 요청할 때, 일부 수정
* **DELETE** : 삭제를 요청할 때

## 쿠키/세션
* **쿠키** : 클라이언트 컴퓨터에 저장되었다가 서버 요청 시 네트워크를 통해 전달됨, 보안 취약
* **세션** : 서버에 저장되고, *브라우저 단위로 관리*, 캐시보다 보안성 좋음 (서버에 저장되는 쿠키)
* **공통점** : 사용자 데이터 저장
* **필요한 이유** : HTTP는 Stateless 하기 때문에, stateful한 서비스를 구현하기 위해서 클라이언트가 누구인지 서버에게 알려줄 필요가 있음

## 캐시
* 서버로부터 전달받은 데이터는 **클라이언트에게 저장**되고, 다음 번 요청을 하면 서버에 요청하지 않고 클라이언트에 있는 데이터를 가져옴
* 이렇게 가져온 데이터를 **캐싱된 데이터**라고 함
* 같은 데이터를 중복 요청하지 않아서 네트워크 자원 절약 가능
* **문제** : 서버에서 데이터가 변경되었는데, 클라이언트가 계속 캐싱된 데이터를 사용하는 경우
* **해결방법** : 캐시 삭제, 서버에서 응답을 보낼 때 헤더에 캐시 만료 시간 전달

## Restful
* HTTP의 규칙을 충실하게 따른 아키텍처
* 해당 URL만 보더라도 어떤 작업을 수행하기 위한 것인지 파악 가능하도록 하나의 데이터에 대한 처리는 하나의 URL을 가지는 것
* **주요 구성요소** : 자원(URI), 행위(method), 표현
* 참고링크 : [REST API 제대로 알고 사용하기](https://meetup.toast.com/posts/92)

## OSI 7 Layer, TCP/IP 4 Layer
### OSI 7계층
* 서로 다른 장치 간의 통신을 위한 규약
* 각 계층별로 통신에 필요한 규약을 정해놓고 해당 규약을 따름으로써 서로 다른 종류의 장비끼리 통신이 가능하게 함
* **종류** : 물리(비트 전송), 데이터 링크(MAC, 에러 탐지), 네트워크(라우팅, IP), **전송**(출발지-목적지 통신 제어, TCP/UDP), 세션(인증, 허가), 표현(암호화), **응용**(HTTP)
* 참고링크 : [서버개발자 면접 질문 정리 - OSI 7 Layer](https://tramyu.github.io/etc/interview/)

### TCP/IP
* **TCP** : 데이터의 확실한 전송을 보장, 신뢰도는 높지만 느림
* **3-way handshaking** : 커넥션을 연결할 때,
* **4-way handshaking** : 커넥션을 끊을 때
* **UDP** : 데이터의 확실한 전송을 확인하지 않고 일방적으로 전송, 빠르지만 손실 발생 가능

***
# 데이터베이스
## 트랜잭션
### 트랜잭션의 특징(ACID)
* **A(Atomicty)** : 원자성, 완료되지 않은 트랜잭션의 중간 상태를 데이터베이스에 반영할 수 없음
* **C(Consistency)** : 일관성, 트랜잭션 진행과정 동안 데이터베이스가 바뀌더라도, 처음에 트랜잭션을 진행하기 위해 참조한 데이터베이스의 상태대로 진행
* **I(Isolation)** : 독립성, 둘 이상의 트랜잭션이 병행 실행될 때, 다른 트랜잭션의 연산에 끼어들 수 없음, 하나의 특정 트랜잭션이 완료될 때 까지 트랜잭션의 결과를 참조할 수 없음
* **D(Durability)** : 트랜잭션이 성공적으로 완료되었을 때, 결과가 영구적으로 반영되어야 함
### Commit/Rollback
* **Commit** : 하나의 트랜잭션이 성공적으로 수행되었을 때, 트랜잭션이 종료되었음을 데이터베이스에 알리는 연산
* **Rollback** : 트랜잭션이 정상적으로 수행되지 않아서 다시 처음부터 수행해야 하거나 *부분적으로만 연산된 결과를 취소하기 위해* 사용하는 연산

## 인덱스
### Clustered Index
* 테이블당 하나만 생성되며, 일반적으로 PK에 생성
* 지정한 열에 대해 내용 자체가 정렬(**자동정렬**)되어 있어 빠르게 검색이 가능

### NonClustered Index

## SELECT

## JOIN
* 두 개 이상의 테이블이나 데이터베이스를 연결하여 검색하는 방법
* 검색하고 싶은 컬럼이 다른 테이블에 있을 경우 주로 사용, 여러 테이블을 하나처럼 사용
* Primary key, Foreign key로 테이블을 연결


***
# 참고링크
* [신입 웹개발자 면접을 위한 스프링 정리](https://private.tistory.com/3)
* [웹개발 관련 예상 면접 질문](https://rongscodinghistory.tistory.com/44)
* [트랜잭션이란?](https://mommoo.tistory.com/62)
* [서블릿 JSP 차이와 관계](https://gmlwjd9405.github.io/2018/11/04/servlet-vs-jsp.html)
