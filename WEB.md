# 자바
아직 공부 중, 기초적인 문법과 프로그래밍 언어의 특징만 알고 있는 수준.

## 자바란
* 썬 마이크로 시스템즈에서 개발한 **객체지향** 프로그래밍 언어

## 자바의 특징
### OOP
* **프로그래밍** : 일련의 제어를 통해 원하는 결과를 얻거나 동작을 수행하도록 프로그램을 만드는 것
* (반대개념) **절차지향** : 필요한 제어들을 순서에 따라 절차적으로 나열하는 것
* **객체지향** : 연관 있는 제어와 필요한 속성을 묶어 객체로 만들고, 객체 간의 상호작용을 통해 프로그램을 구성하는 것
* **특징** : 캡슐화, 은닉화, 상속, 다형성

### 멀티 쓰레드 지원
* **쓰레드** : 프로세스(실행중인 프로그램)에서 하나의 실행 흐름
* **멀티쓰레드** : 하나의 프로그램에서 여러 개의 쓰레드를 사용하는 것
* **사용하는 이유** : 입/출력과 같이 대기 시간이 발생했을 때, 기다리는 동안 다른 일을 처리할 수 있도록 하기 위함(처리 속도의 향상)
* **참고링크** : [자바에서 멀티쓰레드 생성하는 법](https://recruit.webtoonscorp.com/webtoon/ko/login/login?annoId=20002577&classId=&jobId=&entTypeCd=004&sysCompanyCd=NW)

### JVM
* 자바 파일은 자바 컴파일러를 통해 클래스 파일로 변환됨
* 변환된 클래스 파일은 자바 virtual machine 위에서 동작
* 따라서 운영체제에 관계없이 동일한 자바 파일을 사용할 수 있음 (OS 종속성)
* = OS 종속성이 적고, *이식성, 보안성이 좋음*

### 가비지 컬렉션(GC)
* C/C++에서 동적으로 생성한 메모리를 delete로 해제하는 것과 달리 가비지 컬렉터가 알아서 메모리를 회수
* 

## 메모리 영역
* **메서드 영역** : static 변수, 전역변수, class 정보
* (코드에서 사용되는 class들을 로더로 읽어 클래스별로 런타임 필드데이터, 메서드 데이터 등을 분류해 저장)
* **스택** : 지역변수, 함수 등이 할당되는 LIFO 방식의 메모리
* **힙** : new 연산자로 생성된 객체, GC에 의해 메모리 관리

## 추상메서드/추상클래스
* **추상메서드** : 메서드의 정의 부분만 있고 구현부는 없는 것, abstract 키워드를 붙여서 명시
* **추상클래스** : 추상메서드를 적어도 하나 가지고 있는 클래스, 자식클래스에스 오버라이딩이 필요하기 때문에, 객체화(메모리에 올리기) 불가능

## 클래스/객체
* **클래스** : 객체의 동작과 속성을 추려내서 필드와 메서드로 정의한 것, 메모리 할당되지 않은 상태
* **객체** : 클래스를 기반으로 실제 메모리에 할당되어 사용중인 것

## 인터페이스
* **무엇** : 모든 메서드가 추상메서드인 추상클래스, abstract 키워드 없어도 자동으로 추상메서드로 정의되며, 변수도 `final static` 키워드가 자동으로 붙음
* **왜 사용** : 객체의 내부 구조를 몰라도 메서드의 실행 결과(리턴 타입)를 알기 때문에, 작업이 가능하고 객체가 수정 되더라도 사용하는 부분은 수정하지 않아도 됨
* 특정 작업을 하겠다는 Mark 역할로도 활용


***
# 운영체제
## 프로세스
* OS가 메모리 자원을 할당해 준 실행중인 프로그램
* 각 프로세스는 독자적인 메모리 공간을 가지기 때문에, 프로세스 간 데이터 공유 불가능
* **프로세스 간 데이터 공유** : IPC(InterProcess Communication) 필요 - socket, pipe

## 쓰레드
### 멀티쓰레드의 문제점
* 같은 프로세스 내의 쓰레드 간에는 메모리를 공유하기 때문에, 서로 다른 쓰레드가 같은 메모리에 접근해서 다른 쓰레드의 작업 영역을 침범하는 문제가 발생할 수 있다. 그 결과 의도하지 않은 결과를 얻게 된다.
* **요약**) 크리티컬 섹션(공유 메모리)로 인해 원하지 않는 결과를 얻을 수 있음
* **쓰레드 스케쥴링** : 쓰레드 간의 실행 스케쥴링은 임의로 되기 때문에, 적절하지 못한 순간에 다른 쓰레드로 제어가 넘어가면 위와 같이 예상하지 못한 문제가 발생
* **[해결 방법](https://sibnt.net/186)** : 크리티컬 섹션을 사용 중일 때, 다른 쓰레드가 사용하지 못하도록 함
(*크리티컬 섹션의 Synchronization*) = Synchronizaton으로 크리티컬 섹션에 lock을 걸어 다른 쓰레드의 접근 방지(단점: 느려진다)
* **쓰레드 풀** : 쓰레드 생성 갯수를 제한하지 않으면, 메모리를 다 차지할 만큼 쓰레드를 생성할 수 있기 때문에 최대 갯수를 지정해주는 것
* **쓰레드 세이프** : 멀티 쓰레드로 동작하는 프로그램에서 개발자가 의도한 대로 동작하는 것

### 데드락
* 쓰레드 간의 대기상태가 종료되지 않아서 무한정 대기만 하는 상태(교착상태)
* **해결 방법** : 

***
# 웹 프로그래밍
## 쿠키/세션
* **쿠키** : 클라이언트 컴퓨터에 저장되었다가 서버 요청 시 네트워크를 통해 전달됨, 보안 취약
* **세션** : 서버에 저장되고, *브라우저 단위로 관리*, 캐시보다 보안성 좋음 (서버에 저장되는 쿠키)
* **공통점** : 사용자 데이터 저장
* **필요한 이유** : HTTP는 Stateless 하기 때문에, stateful한 서비스를 구현하기 위해서 클라이언트가 누구인지 서버에게 알려줄 필요가 있음

## 캐시
* 서버로부터 전달받은 데이터는 **클라이언트에게 저장**되고, 다음 번 요청을 하면 서버에 요청하지 않고 클라이언트에 있는 데이터를 가져옴
* 이렇게 가져온 데이터를 **캐싱된 데이터**라고 함
* 같은 데이터를 중복 요청하지 않아서 네트워크 자원 절약 가능
* **문제** : 서버에서 데이터가 변경되었는데, 클라이언트가 계속 캐싱된 데이터를 사용하는 경우
* **해결방법** : 캐시 삭제, 서버에서 응답을 보낼 때 헤더에 캐시 만료 시간 전달
